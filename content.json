[{"title":"String","date":"2020-03-20T16:00:00.000Z","path":"2020/03/21/basic/String/","text":"1. 应该熟悉的知识点https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E4%BA%8Cstring String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承） 在 Java 8 中，String 内部使用 char 数组存储数据。 12345public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[];&#125; 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。 12345678public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final byte[] value; /** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. */ private final byte coder;&#125; value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 2. 不可变的好处1. 可以缓存 hash 值因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 2. String Pool 的需要如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 3. 安全性String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。 4. 线程安全String 不可变性天生具备线程安全，可以在多个线程中安全地使用。 区分 String 、StringBuffer and StringBuilder 可变性 String 不可变StringBuffer 和 StringBuilder 可变 线程安全 String 不可变，因此是线程安全的StringBuilder 不是线程安全的StringBuffer 是线程安全的，内部使用 synchronized 进行同步 3. String Pool (重点理解) 直接使用双引号声明出来的String对象会直接存储在常量池中。如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中 调用intern方法时，如果池中已包含由equals（object）方法确定的与此string对象相等的字符串，则返回池中的字符串引用。否则，此字符串对象将添加到池中，并返回对此字符串对象的引用。 下面示例中，s1 用 new String() 的方式创建了2个对象，第一个对象是存储在常量池中的”abc”字符串对象（前提是常量池中还没有 &quot;abc&quot; 字符串对象），第二个对象 JAVA Heap 中的 String 对象。s2 同理。s1.intern(); 这一句是 s1 对象去常量池中寻找后发现 “abc” 已经在常量池里了。所以返回池中的字符串引用，s3（s4）负责接收。因此 s3 和 s4 的引用指向常量池同一个字符串。当 s2 执行new String(“abc”);时，因为常量池已经存在“abc”了，所以仅在 JAVA Heap 中创建 String 对象 123456String s1 = new String(\"abc\");String s2 = new String(\"abc\");System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = \"bbb\";String s6 = \"bbb\";System.out.println(s5 == s6); // true 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError(内存溢出) 错误。 (￣&lt; ￣)&gt; 深入解析String#intern","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"装箱和拆箱","date":"2020-03-19T16:00:00.000Z","path":"2020/03/20/basic/Auto_Un_Boxing/","text":"1. 基本数据类型 一个字节等于8位；1 byte = 8 bit byte/8 char/16 short/16 int/32 float/32 long/64 double/64 boolean 2. （自动）装箱和拆箱讲的是什么？ 装箱：自动将基本数据类型转换为与其自身对应的包装器类型；拆箱：自动将包装器类型转换为与其自身对应的基本数据类型 [看下面的表格(￣▽￣)~*] 基本数据类型 int byte short long double char short boolean 包装器类型 Integer Byte Short Long Double Character Short Boolean 接下来利用代码去搞懂究竟讲的是什么！（ε=ε=ε=┏(゜ロ゜;)┛ Integer obj = 10; //装箱 系统自动为我们执行了 Integer.valueOf(int i); 此处 int i = 10,为int基本数据类型转Integer int num = obj; //拆箱 系统自动为我们执行了 obj.intValue(); 此处 obj为Integer包装器类型转int基本数据类型 接下来看一下Integer.valueOf(int i);的代码，帮助我们理解他的作用 (￣▽￣)~* （先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。） 123456789101112* This method will always cache values in the range -128 to 127。 * ﹌○﹋喔嗨呦 注解指出了Integer 缓存池的大小默认为 -128~127。 * inclusive, and may cache other values outside of this range. * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 那我们再来看看是不是真的这样？还真是这样 （逃 Integer m = 10; Integer n = 10; System.out.println(m == n); // true如果不在缓存池的范围呢？ Integer m = 200; Integer n = 200; System.out.println(m == n); // false由此可见，不在缓存池的范围会执行第11行return new Integer(i);的代码,通过new生成的两个Integer对象,内存中的地址是不同的;同样,还可以这样表示,调用方法相同 Integer m = Integer.valueOf(100); Integer n = Integer.valueOf(100); System.out.println(m == n); // true Integer a = Integer.valueOf(200); Integer b = Integer.valueOf(200); System.out.println(a == b); // false另外一种情况是 Integer m = new Integer(100); Integer n = 100; System.out.println(n == m); //false这个是什么原因呢？(⊙＿⊙) ·因为非new生成的Integer变量指向的是java缓存池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同。你想啊，一个在堆中单独开辟的缓存池中拿数据，一个在堆的其他区域中拿数据，地址当然不同了。 既然这样，当new XXX 的时候比较的就是堆中的地址喽 ^o^y ，那举个栗子 Integer i = new Integer(100); Integer j = new Integer(100); System.out.println(i == j); //false仅以 Integer 为例，其他类型略有差别。 3. 在运算比较中认识装箱和拆箱思考下面的代码 1234567Integer m = new Integer(100); //在缓存区范围int n = 100;System.out.println(m == n); //true 基本数据类型比较，这里的m会自动拆箱为int类型，再与n进行数值比较，非对象地址值比较。Integer m2 = new Integer(200); //不在缓存区范围int n2 = 200;System.out.println(m2 == n2); //true 同理。仅仅是数值作比较 当new XXX 的时候比较的就是堆中的地址,但这里是基本int基本数据类型比较 再看数值比较情况不同的情况 1234567891011Integer m = 200;Double n = 200.0;System.out.println(m.equals(n)); //false//根据equals方法思考原因public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; //Double 与 Integer 非同类型，返回false return value == ((Integer)obj).intValue(); &#125; return false; &#125; &emsp; 以上。","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"你好,再见","date":"2020-03-17T16:00:00.000Z","path":"2020/03/18/basic/Hi/","text":"有时候我觉得，我们确实需要点乐趣的。 以上。","comments":true,"tags":[{"name":"notes","slug":"notes","permalink":"https://pcp20.github.io/tags/notes/"}]}]