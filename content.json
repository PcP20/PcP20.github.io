[{"title":"装箱和拆箱","date":"2020-03-19T16:00:00.000Z","path":"2020/03/20/basic/Auto_Un_Boxing/","text":"1. 基本数据类型 一个字节等于8位；1 byte = 8 bit byte/8 char/16 short/16 int/32 float/32 long/64 double/64 boolean 2. （自动）装箱和拆箱讲的是什么？ 装箱：自动将基本数据类型转换为与其自身对应的包装器类型；拆箱：自动将包装器类型转换为与其自身对应的基本数据类型 [看下面的表格(￣▽￣)~*] 基本数据类型 int byte short long double char short boolean 包装器类型 Integer Byte Short Long Double Character Short Boolean 接下来利用代码去搞懂究竟讲的是什么！（ε=ε=ε=┏(゜ロ゜;)┛ Integer obj = 10; //装箱 系统自动为我们执行了 Integer.valueOf(int i); 此处 int i = 10,为int基本数据类型转Integer int num = obj; //拆箱 系统自动为我们执行了 obj.intValue(); 此处 obj为Integer包装器类型转int基本数据类型 接下来看一下Integer.valueOf(int i);的代码，帮助我们理解他的作用 (￣▽￣)~* （先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。） 123456789101112* This method will always cache values in the range -128 to 127。 * ﹌○﹋喔嗨呦 注解指出了Integer 缓存池的大小默认为 -128~127。 * inclusive, and may cache other values outside of this range. * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 那我们再来看看是不是真的这样？还真是这样 （逃 Integer m = 10; Integer n = 10; System.out.println(m == n); // true如果不在缓存池的范围呢？ Integer m = 200; Integer n = 200; System.out.println(m == n); // false由此可见，不在缓存池的范围会执行第11行return new Integer(i);的代码,通过new生成的两个Integer对象,内存中的地址是不同的;同样,还可以这样表示,调用方法相同 Integer m = Integer.valueOf(100); Integer n = Integer.valueOf(100); System.out.println(m == n); // true Integer a = Integer.valueOf(200); Integer b = Integer.valueOf(200); System.out.println(a == b); // false另外一种情况是 Integer m = new Integer(100); Integer n = 100; System.out.println(n == m); //false这个是什么原因呢？(⊙＿⊙) ·因为非new生成的Integer变量指向的是java缓存池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同。你想啊，一个在堆中单独开辟的缓存池中拿数据，一个在堆的其他区域中拿数据，地址当然不同了。 既然这样，当new XXX 的时候比较的就是堆中的地址喽 ^o^y ，那举个栗子 Integer i = new Integer(100); Integer j = new Integer(100); System.out.println(i == j); //false仅以 Integer 为例，其他类型略有差别。 3. 在运算比较中认识装箱和拆箱思考下面的代码 1234567Integer m = new Integer(100); //在缓存区范围int n = 100;System.out.println(m == n); //true 基本数据类型比较，这里的m会自动拆箱为int类型，再与n进行数值比较，非对象地址值比较。Integer m2 = new Integer(200); //不在缓存区范围int n2 = 200;System.out.println(m2 == n2); //true 同理。仅仅是数值作比较 当new XXX 的时候比较的就是堆中的地址,但这里是基本int基本数据类型比较 再看数值比较情况不同的情况 1234567891011Integer m = 200;Double n = 200.0;System.out.println(m.equals(n)); //false//根据equals方法思考原因public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; //Double 与 Integer 非同类型，返回false return value == ((Integer)obj).intValue(); &#125; return false; &#125; &emsp; 以上。","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"你好,再见","date":"2020-03-17T16:00:00.000Z","path":"2020/03/18/basic/Hi/","text":"有时候我觉得，我们确实需要点乐趣的。 以上。","comments":true,"tags":[{"name":"notes","slug":"notes","permalink":"https://pcp20.github.io/tags/notes/"}]}]