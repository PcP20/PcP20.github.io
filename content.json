[{"title":"hashCode()","date":"2020-03-22T12:06:21.000Z","path":"2020/03/22/basic/hashCode/","text":"&emsp;可参考：hashCode内容hashCode的作用","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"Static","date":"2020-03-22T08:06:21.000Z","path":"2020/03/22/basic/Static/","text":"&emsp;Static内容来源 1. 静态变量静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 123456789101112public class A &#123; private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) &#123; // int x = A.x; // Non-static field 'x' cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; &#125;&#125; 2. 静态方法静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 12345public abstract class A &#123; public static void func1()&#123; &#125; // public abstract static void func2(); // Illegal combination of modifiers: 'abstract' and 'static'&#125; 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。 1234567891011public class A &#123; private static int x; private int y; public static void func1()&#123; int a = x; // int b = y; // Non-static field 'y' cannot be referenced from a static context // int b = this.y; // 'A.this' cannot be referenced from a static context &#125;&#125; 3. 静态语句块静态语句块在类初始化时运行一次。 12345678910public class A &#123; static &#123; System.out.println(\"123\"); &#125; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new A(); &#125;&#125; 4. 静态内部类非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。 123456789101112131415public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 5. 静态导包在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 import static com.xxx.ClassName.* 6. 初始化顺序静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 12345678public static String staticField = \"静态变量\";static &#123; System.out.println(\"静态语句块\");&#125;public String field = \"实例变量\";&#123; System.out.println(\"普通语句块\");&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println(\"构造函数\");&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块）子类（静态变量、静态语句块）父类（实例变量、普通语句块）父类（构造函数）子类（实例变量、普通语句块）子类（构造函数）","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"深入理解final","date":"2020-03-21T16:00:00.000Z","path":"2020/03/22/basic/Final/","text":"&emsp;final内容来源 数据 声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变；对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 final int x = 1; // x = 2; // cannot assign value to final variable 'x' final A y = new A(); y.a = 1; 方法 使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的 Java 版本中，不需要使用 final 方法进行这些优化了。 声明方法不能被子类重写。 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 类 声明类不允许被继承。 final漫画理解","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"String","date":"2020-03-20T16:00:00.000Z","path":"2020/03/21/basic/String/","text":"1. 应该熟悉的知识点https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E4%BA%8Cstring String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承） 在 Java 8 中，String 内部使用 char 数组存储数据。 12345public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[];&#125; 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。 12345678public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final byte[] value; /** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. */ private final byte coder;&#125; value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 2. 不可变的好处1. 可以缓存 hash 值因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 2. String Pool 的需要如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 3. 安全性String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。 4. 线程安全String 不可变性天生具备线程安全，可以在多个线程中安全地使用。 区分 String 、StringBuffer and StringBuilder 可变性 String 不可变StringBuffer 和 StringBuilder 可变 线程安全 String 不可变，因此是线程安全的StringBuilder 不是线程安全的StringBuffer 是线程安全的，内部使用 synchronized 进行同步 3. String Pool (重点理解) 直接使用双引号声明出来的String对象会直接存储在常量池中。如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中 调用intern方法时，如果池中已包含由equals（object）方法确定的与此string对象相等的字符串，则返回池中的字符串引用。否则，此字符串对象将添加到池中，并返回对此字符串对象的引用。 下面示例中，s1 用 new String() 的方式创建了2个对象，第一个对象是存储在常量池中的”abc”字符串对象（前提是常量池中还没有 &quot;abc&quot; 字符串对象），第二个对象 JAVA Heap 中的 String 对象。s2 同理。s1.intern(); 这一句是 s1 对象去常量池中寻找后发现 “abc” 已经在常量池里了。所以返回池中的字符串引用，s3（s4）负责接收。因此 s3 和 s4 的引用指向常量池同一个字符串。当 s2 执行new String(“abc”);时，因为常量池已经存在“abc”了，所以仅在 JAVA Heap 中创建 String 对象 123456String s1 = new String(\"abc\");String s2 = new String(\"abc\");System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = \"bbb\";String s6 = \"bbb\";System.out.println(s5 == s6); // true 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError(内存溢出) 错误。 (￣&lt; ￣)&gt; 深入解析String#intern (￣&lt; ￣)&gt; 深入理解Java中的String","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"装箱和拆箱","date":"2020-03-19T16:00:00.000Z","path":"2020/03/20/basic/Auto_Un_Boxing/","text":"1. 基本数据类型 一个字节等于8位；1 byte = 8 bit byte/8 char/16 short/16 int/32 float/32 long/64 double/64 boolean 2. （自动）装箱和拆箱讲的是什么？ 装箱：自动将基本数据类型转换为与其自身对应的包装器类型；拆箱：自动将包装器类型转换为与其自身对应的基本数据类型 [看下面的表格(￣▽￣)~*] 基本数据类型 int byte short long double char short boolean 包装器类型 Integer Byte Short Long Double Character Short Boolean 接下来利用代码去搞懂究竟讲的是什么！（ε=ε=ε=┏(゜ロ゜;)┛ Integer obj = 10; //装箱 系统自动为我们执行了 Integer.valueOf(int i); 此处 int i = 10,为int基本数据类型转Integer int num = obj; //拆箱 系统自动为我们执行了 obj.intValue(); 此处 obj为Integer包装器类型转int基本数据类型 接下来看一下Integer.valueOf(int i);的代码，帮助我们理解他的作用 (￣▽￣)~* （先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。） 123456789101112* This method will always cache values in the range -128 to 127。 * ﹌○﹋喔嗨呦 注解指出了Integer 缓存池的大小默认为 -128~127。 * inclusive, and may cache other values outside of this range. * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 那我们再来看看是不是真的这样？还真是这样 （逃 Integer m = 10; Integer n = 10; System.out.println(m == n); // true如果不在缓存池的范围呢？ Integer m = 200; Integer n = 200; System.out.println(m == n); // false由此可见，不在缓存池的范围会执行第11行return new Integer(i);的代码,通过new生成的两个Integer对象,内存中的地址是不同的;同样,还可以这样表示,调用方法相同 Integer m = Integer.valueOf(100); Integer n = Integer.valueOf(100); System.out.println(m == n); // true Integer a = Integer.valueOf(200); Integer b = Integer.valueOf(200); System.out.println(a == b); // false另外一种情况是 Integer m = new Integer(100); Integer n = 100; System.out.println(n == m); //false这个是什么原因呢？(⊙＿⊙) ·因为非new生成的Integer变量指向的是java缓存池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同。你想啊，一个在堆中单独开辟的缓存池中拿数据，一个在堆的其他区域中拿数据，地址当然不同了。 既然这样，当new XXX 的时候比较的就是堆中的地址喽 ^o^y ，那举个栗子 Integer i = new Integer(100); Integer j = new Integer(100); System.out.println(i == j); //false仅以 Integer 为例，其他类型略有差别。 3. 在运算比较中认识装箱和拆箱思考下面的代码 1234567Integer m = new Integer(100); //在缓存区范围int n = 100;System.out.println(m == n); //true 基本数据类型比较，这里的m会自动拆箱为int类型，再与n进行数值比较，非对象地址值比较。Integer m2 = new Integer(200); //不在缓存区范围int n2 = 200;System.out.println(m2 == n2); //true 同理。仅仅是数值作比较 当new XXX 的时候比较的就是堆中的地址,但这里是基本int基本数据类型比较 再看数值比较情况不同的情况 1234567891011Integer m = 200;Double n = 200.0;System.out.println(m.equals(n)); //false//根据equals方法思考原因public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; //Double 与 Integer 非同类型，返回false return value == ((Integer)obj).intValue(); &#125; return false; &#125; &emsp; 以上。","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"你好","date":"2020-03-17T16:00:00.000Z","path":"2020/03/18/basic/Hi/","text":"有时候我觉得，我们确实需要点乐趣的。 以上。","comments":true,"tags":[{"name":"notes","slug":"notes","permalink":"https://pcp20.github.io/tags/notes/"}]}]