[{"title":"继承知识点概要","date":"2020-03-23T01:27:15.000Z","path":"2020/03/23/basic/关于继承/","text":"1. 访问权限 public private default protected不写时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。 不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖 如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。 字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。 123public class AccessExample &#123; public String id;&#125; 2. 抽象类与接口 抽象类抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。 接口接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。 从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。 接口的成员（字段 + 方法）默认都是public 的，并且不允许定义为 private 或者 protected。 接口的字段默认都是 static 和 final 的。 123456789101112131415public interface InterfaceExample &#123; void func1(); default void func2()&#123; System.out.println(\"func2\"); &#125; int x = 123; // int y; // Variable 'y' might not have been initialized public int z = 0; // Modifier 'public' is redundant for interface fields // private int k = 0; // Modifier 'private' not allowed here // protected int l = 0; // Modifier 'protected' not allowed here // private void fun3(); // Modifier 'private' not allowed here&#125; 123456public class InterfaceImplementExample implements InterfaceExample &#123; @Override public void func1() &#123; System.out.println(\"func1\"); &#125;&#125; 1234// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiatedInterfaceExample ie2 = new InterfaceImplementExample();ie2.func1();System.out.println(InterfaceExample.x); 比较 从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 3. 使用选择 使用接口： 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法； 需要使用多重继承。 使用抽象类： 需要在几个相关的类中共享代码。 需要能控制继承来的成员的访问权限，而不是都为 public。 需要继承非静态和非常量字段。 在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"浅拷贝深拷贝","date":"2020-03-22T13:26:21.000Z","path":"2020/03/22/basic/clone/","text":"关键词：引用地址&emsp;可参考：clone方法理解","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"hashCode()","date":"2020-03-22T12:06:21.000Z","path":"2020/03/22/basic/hashCode/","text":"&emsp;可参考：hashCode内容hashCode的作用","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"Static","date":"2020-03-22T08:06:21.000Z","path":"2020/03/22/basic/Static/","text":"&emsp;Static内容来源 1. 静态变量静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 123456789101112public class A &#123; private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) &#123; // int x = A.x; // Non-static field 'x' cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; &#125;&#125; 2. 静态方法静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 12345public abstract class A &#123; public static void func1()&#123; &#125; // public abstract static void func2(); // Illegal combination of modifiers: 'abstract' and 'static'&#125; 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。 1234567891011public class A &#123; private static int x; private int y; public static void func1()&#123; int a = x; // int b = y; // Non-static field 'y' cannot be referenced from a static context // int b = this.y; // 'A.this' cannot be referenced from a static context &#125;&#125; 3. 静态语句块静态语句块在类初始化时运行一次。 12345678910public class A &#123; static &#123; System.out.println(\"123\"); &#125; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new A(); &#125;&#125; 4. 静态内部类非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。 123456789101112131415public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 5. 静态导包在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 import static com.xxx.ClassName.* 6. 初始化顺序静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 12345678public static String staticField = \"静态变量\";static &#123; System.out.println(\"静态语句块\");&#125;public String field = \"实例变量\";&#123; System.out.println(\"普通语句块\");&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println(\"构造函数\");&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块）子类（静态变量、静态语句块）父类（实例变量、普通语句块）父类（构造函数）子类（实例变量、普通语句块）子类（构造函数）","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"深入理解final","date":"2020-03-22T07:06:21.000Z","path":"2020/03/22/basic/Final/","text":"&emsp;final内容来源 数据 声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变；对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 final int x = 1; // x = 2; // cannot assign value to final variable 'x' final A y = new A(); y.a = 1; 方法 声明方法不能被子类重写。 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 类 声明类不允许被继承。 final漫画理解","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"String","date":"2020-03-20T16:00:00.000Z","path":"2020/03/21/basic/String/","text":"1. 应该熟悉的知识点https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E4%BA%8Cstring String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承） 在 Java 8 中，String 内部使用 char 数组存储数据。 12345public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[];&#125; 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。 12345678public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final byte[] value; /** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. */ private final byte coder;&#125; value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 2. 不可变的好处1. 可以缓存 hash 值因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 2. String Pool 的需要如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 3. 安全性String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。 4. 线程安全String 不可变性天生具备线程安全，可以在多个线程中安全地使用。 区分 String 、StringBuffer and StringBuilder 可变性 String 不可变StringBuffer 和 StringBuilder 可变 线程安全 String 不可变，因此是线程安全的StringBuilder 不是线程安全的StringBuffer 是线程安全的，内部使用 synchronized 进行同步 3. String Pool (重点理解) 直接使用双引号声明出来的String对象会直接存储在常量池中。如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中 调用intern方法时，如果池中已包含由equals（object）方法确定的与此string对象相等的字符串，则返回池中的字符串引用。否则，此字符串对象将添加到池中，并返回对此字符串对象的引用。 下面示例中，s1 用 new String() 的方式创建了2个对象，第一个对象是存储在常量池中的”abc”字符串对象（前提是常量池中还没有 &quot;abc&quot; 字符串对象），第二个对象 JAVA Heap 中的 String 对象。s2 同理。s1.intern(); 这一句是 s1 对象去常量池中寻找后发现 “abc” 已经在常量池里了。所以返回池中的字符串引用，s3（s4）负责接收。因此 s3 和 s4 的引用指向常量池同一个字符串。当 s2 执行new String(“abc”);时，因为常量池已经存在“abc”了，所以仅在 JAVA Heap 中创建 String 对象 123456String s1 = new String(\"abc\");String s2 = new String(\"abc\");System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = \"bbb\";String s6 = \"bbb\";System.out.println(s5 == s6); // true 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError(内存溢出) 错误。 (￣&lt; ￣)&gt; 深入解析String#intern (￣&lt; ￣)&gt; 深入理解Java中的String","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"装箱和拆箱","date":"2020-03-19T16:00:00.000Z","path":"2020/03/20/basic/Auto_Un_Boxing/","text":"1. 基本数据类型 一个字节等于8位；1 byte = 8 bit byte/8 char/16 short/16 int/32 float/32 long/64 double/64 boolean 2. （自动）装箱和拆箱讲的是什么？ 装箱：自动将基本数据类型转换为与其自身对应的包装器类型；拆箱：自动将包装器类型转换为与其自身对应的基本数据类型 [看下面的表格(￣▽￣)~*] 基本数据类型 int byte short long double char short boolean 包装器类型 Integer Byte Short Long Double Character Short Boolean 接下来利用代码去搞懂究竟讲的是什么！（ε=ε=ε=┏(゜ロ゜;)┛ Integer obj = 10; //装箱 系统自动为我们执行了 Integer.valueOf(int i); 此处 int i = 10,为int基本数据类型转Integer int num = obj; //拆箱 系统自动为我们执行了 obj.intValue(); 此处 obj为Integer包装器类型转int基本数据类型 接下来看一下Integer.valueOf(int i);的代码，帮助我们理解他的作用 (￣▽￣)~* （先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。） 123456789101112* This method will always cache values in the range -128 to 127。 * ﹌○﹋喔嗨呦 注解指出了Integer 缓存池的大小默认为 -128~127。 * inclusive, and may cache other values outside of this range. * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 那我们再来看看是不是真的这样？还真是这样 （逃 Integer m = 10; Integer n = 10; System.out.println(m == n); // true如果不在缓存池的范围呢？ Integer m = 200; Integer n = 200; System.out.println(m == n); // false由此可见，不在缓存池的范围会执行第11行return new Integer(i);的代码,通过new生成的两个Integer对象,内存中的地址是不同的;同样,还可以这样表示,调用方法相同 Integer m = Integer.valueOf(100); Integer n = Integer.valueOf(100); System.out.println(m == n); // true Integer a = Integer.valueOf(200); Integer b = Integer.valueOf(200); System.out.println(a == b); // false另外一种情况是 Integer m = new Integer(100); Integer n = 100; System.out.println(n == m); //false这个是什么原因呢？(⊙＿⊙) ·因为非new生成的Integer变量指向的是java缓存池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同。你想啊，一个在堆中单独开辟的缓存池中拿数据，一个在堆的其他区域中拿数据，地址当然不同了。 既然这样，当new XXX 的时候比较的就是堆中的地址喽 ^o^y ，那举个栗子 Integer i = new Integer(100); Integer j = new Integer(100); System.out.println(i == j); //false仅以 Integer 为例，其他类型略有差别。 3. 在运算比较中认识装箱和拆箱思考下面的代码 1234567Integer m = new Integer(100); //在缓存区范围int n = 100;System.out.println(m == n); //true 基本数据类型比较，这里的m会自动拆箱为int类型，再与n进行数值比较，非对象地址值比较。Integer m2 = new Integer(200); //不在缓存区范围int n2 = 200;System.out.println(m2 == n2); //true 同理。仅仅是数值作比较 当new XXX 的时候比较的就是堆中的地址,但这里是基本int基本数据类型比较 再看数值比较情况不同的情况 1234567891011Integer m = 200;Double n = 200.0;System.out.println(m.equals(n)); //false//根据equals方法思考原因public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; //Double 与 Integer 非同类型，返回false return value == ((Integer)obj).intValue(); &#125; return false; &#125; &emsp; 以上。","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"你好","date":"2020-03-17T16:00:00.000Z","path":"2020/03/18/basic/Hi/","text":"有时候我觉得，我们确实需要点乐趣的。 以上。","comments":true,"tags":[{"name":"notes","slug":"notes","permalink":"https://pcp20.github.io/tags/notes/"}]}]