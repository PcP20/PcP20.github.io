[{"title":"ArrayList","date":"2020-03-27T10:47:49.000Z","path":"2020/03/27/basic/basic-plus/ArrayList/","text":"源码分析基于 JDK 1.8。 底层数据结构是数组。线程不安全 1. 是什么？ArrayList就是数组列表，主要用来装载数据，当我们装载的是基本类型的数据int，long，boolean，short，byte…的时候我们只能存储他们对应的包装类，它的主要底层实现是数组Object[] elementData。 与它类似的是LinkedList，和LinkedList相比，它的查找和访问元素的速度较快，但新增，删除的速度较慢。 123456/** * The array buffer into which the elements of the ArrayList are stored. * 存储ArrayList的元素的数组缓冲区 */ transient Object[] elementData; // non-private to simplify nested class access 查询效率高，增删效率低，线程不安全。使用频率很高虽然线程不安全,但因为我们正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用LinkedList，如果你需要线程安全就使用Vector，这就是三者的区别了，实际开发过程中还是ArrayList使用最多的。 2. 构造方法123456789101112131415161718192021222324/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125; &#125; /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 数组的默认大小为 10。(调用无参构造方法)private static final int DEFAULT_CAPACITY = 10; 当知道确切插入次数的时候，可以调用有参构造方法，指定初始容量大小，减少扩容操作的次数。 3. 扩容 ？添加元素时使用 ensureCapacityInternal(int minCapacity) 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 oldCapacity + (oldCapacity &gt;&gt; 1)，也就是旧容量的 1.5 倍。 扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。 12345678910111213141516171819202122232425262728293031public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 4. 查询快，增删慢 数组 数组:Array,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。 简单的说,采用该结构的集合，对元素的存取有如下的特点： 查找元素快：通过索引，可以快速访问指定位置的元素 增删元素慢 指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根 据索引，复制到新数组对应索引的位置。如下图 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图 参考一参考二","comments":true,"tags":[{"name":"basic-plus","slug":"basic-plus","permalink":"https://pcp20.github.io/tags/basic-plus/"}]},{"title":"注解","date":"2020-03-26T01:27:15.000Z","path":"2020/03/26/basic/了解注解/","text":"了解注解","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"finally","date":"2020-03-25T13:21:48.000Z","path":"2020/03/25/basic/finally/","text":"&emsp; finally到底是在return之前执行还是return之后执行？finally","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"反射","date":"2020-03-25T08:21:48.000Z","path":"2020/03/25/basic/反射/","text":"&emsp; 1. 反射是干么的？如何定义？反射可以提供运行时的类信息，Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。 2. 通过代码了解基本用法及方法使用Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类： Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段； Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法； Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。 12345package com.c;public class Demo &#123; public int num = 11;&#125; 12345678910111213141516171819202122232425262728293031package com.c;import java.lang.reflect.Field;import java.lang.reflect.Modifier;public class FieldTest &#123; public static void main(String[] args) throws Exception &#123; //使用反射第一步:获取操作类Demo所对应的Class对象 Class&lt;?&gt; cls = Class.forName(\"com.c.Demo\"); //使用Demo类的class对象生成 实例 Object obj = cls.newInstance(); //通过Class类中getField(String name)： 获取类特定的方法，name参数指定了属性的名称 Field field = cls.getField(\"num\"); //拿到了Field类的实例后就可以调用其中的方法了 //方法:getModifiers() 以整数形式返回由此 Field 对象表示的字段的 Java 语言修饰符 System.out.println(\"修饰符: \" + Modifier.toString(field.getModifiers())); //方法:getType() 返回一个 Class 对象，它标识了此 Field 对象所表示字段的声明类型 System.out.println(\"类型: \"+field.getType()); //方法:get(Object obj) 返回指定对象obj上此 Field 表示的字段的值 System.out.println(\"属性值: \"+field.get(obj)); //方法: set(Object obj, Object value) 将指定对象变量上此 Field 对象表示的字段设置为指定的新值 field.set(obj,666); System.out.println(\"修改属性值后 --&gt; get(Object obj): \"+field.get(obj)); &#125;&#125; 运行结果 1234修饰符: public类型: int属性值: 11修改属性值后 --&gt; get(Object obj): 666","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"由clone引出的 protected 问题","date":"2020-03-23T16:00:00.000Z","path":"2020/03/24/basic/由clone引出的 protected 问题/","text":"&emsp; 1. protected修饰的类和属性,对于自己、本包和其子类可见 第一种情况：子类父类在同一个包下,在相同包时,可以理解protected和public是一样的。 1234567891011package com.A; /*注意包的变化*/public class Father &#123; protected int num; protected void demo()&#123; System.out.println(\"父类受保护的方法\"); &#125;&#125; 1234package com.A;public class Son extends Father&#123;&#125; 123456789101112131415161718192021package com.A;public class Girl extends Father &#123; public static void main(String[] args) &#123; //(1)子类实例可以访问其从父类继承而来的protected方法 Girl girl = new Girl(); girl.demo(); //此处的 demo()方法是继承父类的,子类并没有重写 girl.num =10; Son son = new Son(); son.demo(); //(2)父类实例本身的protected方法访问 Father father = new Father(); father.demo(); &#125;&#125; 第二种情况(***)：子类父类不在同一个包下! 不在同一个包下! 不在同一个包下! 结合注解理解 1234567891011121314151617181920212223package com.B; /*注意包的变化*/import com.A.Father;public class Girl extends Father &#123; public static void main(String[] args) &#123; //若子类与基类*不在同一包中*，那么**在子类(Girl)中编写代码**,有下面三种情况 //(1)子类实例可以访问其从基类继承而来的protected方法 Girl girl = new Girl(); girl.demo(); //正常运行 ，此处的 demo()方法是继承父类的,子类并没有重写 //(2)基类实例本身的protected方法不能访问 Father father = new Father(); father.demo(); //Error: java: demo()可以在com.A.Father中访问protected //（3）虽然Son跟Girl在同一个包下，但是它是在人家Girl家里调用demo()方法，编译不通过 Son son = new Son(); son.demo(); //Error: 'demo()' has protected access in 'com.A.Father' &#125;&#125; 记住前提条件：子类与父类不在同一个包下下面的代码写在 Son类中 ，然后new Son()并调用demo()方法是可以正常运行的；但是在Son类中用新建的Girl对象调用继承父类的demo()方法就会编译不通过。 1234567891011121314package com.B; /*注意包的变化*/import com.A.Father;public class Son extends Father&#123; public static void main(String[] args) &#123; Son son = new Son(); son.demo(); //正常运行，此处的 demo()方法是继承父类的,子类并没有重写 Girl girl = new Girl(); girl.demo(); //Error: java: demo()可以在com.A.Father中访问protected &#125;&#125; 如果还不理解，再看下面的代码: 在 Test类中 ，子类分别调用demo()方法，同样编译不通过。可以理解为，虽然大家都是兄弟，在自己家搞事情可以，去兄弟家搞事情不行 （逃 123456789101112131415package com.B;import com.A.Father;public class Test extends Father&#123; public static void main(String[] args) &#123; Girl girl = new Girl(); girl.demo(); //Error: java: demo()可以在com.A.Father中访问protected Son son = new Son(); son.demo(); //Error: java: demo()可以在com.A.Father中访问protected &#125;&#125; 如果想要子类可以执行demo()方法，需要在子类中重写 2. 浅克隆的例子(深克隆由于扩展性的需要，重写父类protected的clone方法便于开发)1234567891011121314151617181920212223242526272829package com.c;/** * Cloneable是标记型的接口，它们内部都没有方法和属性，实现 Cloneable来表示该对象能被克隆， * 能使用Object.clone()方法。如果没有实现 Cloneable的类对象调用clone()就会抛出CloneNotSupportedException。 */public class Demo implements Cloneable&#123; private int num; public Demo(int num) &#123; this.num = num; &#125; public Demo() &#123; &#125; public static void main(String[] args) throws CloneNotSupportedException &#123; Demo demo = new Demo(100); Demo demoClone = (Demo)demo.clone(); /*两个对象的地址是不同的，也就是说创建了新的对象*/ System.out.println(demo); //com.c.Demo@1b6d3586 System.out.println(demoClone); //com.c.Demo@4554617c System.out.println(demo.num); // 100 System.out.println(demoClone.num); // 100 &#125;&#125; 总结克隆有什么好处？ 使用方便：假如要复制一个对象，但这个对象中的部分属性已经被修改过了，如果不使用克隆的话，需要给属性手动赋值，相比克隆而已麻烦很多； 性能高：查看 clone 方法可以知道，它是 native 方法，native 方法是原生函数，使用操作系统底层的语言实现的，因此执行效率更高； 隔离性：克隆可以确保对象操作时相互隔离。 深克隆如何实现？有几种实现方式？ 通过序列化实现深克隆（序列化实现方式：Java 原生序列化、JSON 序列化、Hessian 序列化）； 所有引用类型都实现克隆，从而实现深克隆。 调用 Object 类中的 clone() 方法默认是浅克隆，浅克隆只能复制值类型，不能复制引用类型，因此更多的场景下我们需要深克隆，深克隆通常的实现方式有两种：序列化方式或把所有的引用类型都实现克隆。 为什么不能直接使用 Object 的 Clone 方法，还要重写 clone() 方法之后才能实现克隆？ 虽然所有类都是 Object 的子类，但因为 Object 中的 clone() 方法被声明为 protected 访问级别，所以非 java.lang 包下的其他类是不能直接使用的。因此要想实现克隆功能，就必须实现 Cloneable，并重写 clone() 方法才行。 序列化可不可以实现深克隆？实现的原理是什么？ 先将原对象序列化到内存的字节流中，再从字节流中反序列化出刚刚存储的对象，这个新对象和原对象就不存在任何地址上的共享，这样就实现了深克隆。","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"继承知识点概要","date":"2020-03-23T01:27:15.000Z","path":"2020/03/23/basic/关于继承/","text":"&emsp; 1. 访问权限 public private default protected不写时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。 不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖 如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。 字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。 123public class AccessExample &#123; public String id;&#125; 2. 抽象类与接口 抽象类抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。 接口接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。 从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。 接口的成员（字段 + 方法）默认都是public 的，并且不允许定义为 private 或者 protected。 接口的字段默认都是 static 和 final 的。 123456789101112131415public interface InterfaceExample &#123; void func1(); default void func2()&#123; System.out.println(\"func2\"); &#125; int x = 123; // int y; // Variable 'y' might not have been initialized public int z = 0; // Modifier 'public' is redundant for interface fields // private int k = 0; // Modifier 'private' not allowed here // protected int l = 0; // Modifier 'protected' not allowed here // private void fun3(); // Modifier 'private' not allowed here&#125; 123456public class InterfaceImplementExample implements InterfaceExample &#123; @Override public void func1() &#123; System.out.println(\"func1\"); &#125;&#125; 1234// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiatedInterfaceExample ie2 = new InterfaceImplementExample();ie2.func1();System.out.println(InterfaceExample.x); 比较 从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 3. 使用选择 使用接口： 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法； 需要使用多重继承。 使用抽象类： 需要在几个相关的类中共享代码。 需要能控制继承来的成员的访问权限，而不是都为 public。 需要继承非静态和非常量字段。 在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"浅拷贝深拷贝","date":"2020-03-22T13:26:21.000Z","path":"2020/03/22/basic/clone/","text":"关键词：引用地址&emsp;可参考：clone方法理解","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"hashCode()","date":"2020-03-22T12:06:21.000Z","path":"2020/03/22/basic/hashCode/","text":"&emsp;可参考：hashCode内容hashCode的作用","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"Static","date":"2020-03-22T08:06:21.000Z","path":"2020/03/22/basic/Static/","text":"&emsp;Static内容来源 1. 静态变量静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 123456789101112public class A &#123; private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) &#123; // int x = A.x; // Non-static field 'x' cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; &#125;&#125; 2. 静态方法静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 12345public abstract class A &#123; public static void func1()&#123; &#125; // public abstract static void func2(); // Illegal combination of modifiers: 'abstract' and 'static'&#125; 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。 1234567891011public class A &#123; private static int x; private int y; public static void func1()&#123; int a = x; // int b = y; // Non-static field 'y' cannot be referenced from a static context // int b = this.y; // 'A.this' cannot be referenced from a static context &#125;&#125; 3. 静态语句块静态语句块在类初始化时运行一次。 12345678910public class A &#123; static &#123; System.out.println(\"123\"); &#125; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new A(); &#125;&#125; 4. 静态内部类非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。 123456789101112131415public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 5. 静态导包在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 import static com.xxx.ClassName.* 6. 初始化顺序静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 12345678public static String staticField = \"静态变量\";static &#123; System.out.println(\"静态语句块\");&#125;public String field = \"实例变量\";&#123; System.out.println(\"普通语句块\");&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println(\"构造函数\");&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块）子类（静态变量、静态语句块）父类（实例变量、普通语句块）父类（构造函数）子类（实例变量、普通语句块）子类（构造函数）","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"深入理解final","date":"2020-03-22T07:06:21.000Z","path":"2020/03/22/basic/Final/","text":"&emsp;final内容来源 数据 声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变；对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 final int x = 1; // x = 2; // cannot assign value to final variable 'x' final A y = new A(); y.a = 1; 方法 声明方法不能被子类重写。 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 类 声明类不允许被继承。 final漫画理解","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"String","date":"2020-03-20T16:00:00.000Z","path":"2020/03/21/basic/String/","text":"1. 应该熟悉的知识点https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E4%BA%8Cstring String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承） 在 Java 8 中，String 内部使用 char 数组存储数据。 12345public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[];&#125; 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。 12345678public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final byte[] value; /** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. */ private final byte coder;&#125; value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 2. 不可变的好处1. 可以缓存 hash 值因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 2. String Pool 的需要如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 3. 安全性String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。 4. 线程安全String 不可变性天生具备线程安全，可以在多个线程中安全地使用。 区分 String 、StringBuffer and StringBuilder 可变性 String 不可变StringBuffer 和 StringBuilder 可变 线程安全 String 不可变，因此是线程安全的StringBuilder 不是线程安全的StringBuffer 是线程安全的，内部使用 synchronized 进行同步 3. String Pool (重点理解) 直接使用双引号声明出来的String对象会直接存储在常量池中。如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中 调用intern方法时，如果池中已包含由equals（object）方法确定的与此string对象相等的字符串，则返回池中的字符串引用。否则，此字符串对象将添加到池中，并返回对此字符串对象的引用。 下面示例中，s1 用 new String() 的方式创建了2个对象，第一个对象是存储在常量池中的”abc”字符串对象（前提是常量池中还没有 &quot;abc&quot; 字符串对象），第二个对象 JAVA Heap 中的 String 对象。s2 同理。s1.intern(); 这一句是 s1 对象去常量池中寻找后发现 “abc” 已经在常量池里了。所以返回池中的字符串引用，s3（s4）负责接收。因此 s3 和 s4 的引用指向常量池同一个字符串。当 s2 执行new String(“abc”);时，因为常量池已经存在“abc”了，所以仅在 JAVA Heap 中创建 String 对象 123456String s1 = new String(\"abc\");String s2 = new String(\"abc\");System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = \"bbb\";String s6 = \"bbb\";System.out.println(s5 == s6); // true 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError(内存溢出) 错误。 (￣&lt; ￣)&gt; 深入解析String#intern (￣&lt; ￣)&gt; 深入理解Java中的String","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"装箱和拆箱","date":"2020-03-19T16:00:00.000Z","path":"2020/03/20/basic/Auto_Un_Boxing/","text":"1. 基本数据类型 一个字节等于8位；1 byte = 8 bit byte/8 char/16 short/16 int/32 float/32 long/64 double/64 boolean 2. （自动）装箱和拆箱讲的是什么？ 装箱：自动将基本数据类型转换为与其自身对应的包装器类型；拆箱：自动将包装器类型转换为与其自身对应的基本数据类型 [看下面的表格(￣▽￣)~*] 基本数据类型 int byte short long double char short boolean 包装器类型 Integer Byte Short Long Double Character Short Boolean 接下来利用代码去搞懂究竟讲的是什么！（ε=ε=ε=┏(゜ロ゜;)┛ Integer obj = 10; //装箱 系统自动为我们执行了 Integer.valueOf(int i); 此处 int i = 10,为int基本数据类型转Integer int num = obj; //拆箱 系统自动为我们执行了 obj.intValue(); 此处 obj为Integer包装器类型转int基本数据类型 接下来看一下Integer.valueOf(int i);的代码，帮助我们理解他的作用 (￣▽￣)~* （先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。） 123456789101112* This method will always cache values in the range -128 to 127。 * ﹌○﹋喔嗨呦 注解指出了Integer 缓存池的大小默认为 -128~127。 * inclusive, and may cache other values outside of this range. * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 那我们再来看看是不是真的这样？还真是这样 （逃 Integer m = 10; Integer n = 10; System.out.println(m == n); // true如果不在缓存池的范围呢？ Integer m = 200; Integer n = 200; System.out.println(m == n); // false由此可见，不在缓存池的范围会执行第11行return new Integer(i);的代码,通过new生成的两个Integer对象,内存中的地址是不同的;同样,还可以这样表示,调用方法相同 Integer m = Integer.valueOf(100); Integer n = Integer.valueOf(100); System.out.println(m == n); // true Integer a = Integer.valueOf(200); Integer b = Integer.valueOf(200); System.out.println(a == b); // false另外一种情况是 Integer m = new Integer(100); Integer n = 100; System.out.println(n == m); //false这个是什么原因呢？(⊙＿⊙) ·因为非new生成的Integer变量指向的是java缓存池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同。你想啊，一个在堆中单独开辟的缓存池中拿数据，一个在堆的其他区域中拿数据，地址当然不同了。 既然这样，当new XXX 的时候比较的就是堆中的地址喽 ^o^y ，那举个栗子 Integer i = new Integer(100); Integer j = new Integer(100); System.out.println(i == j); //false仅以 Integer 为例，其他类型略有差别。 3. 在运算比较中认识装箱和拆箱思考下面的代码 1234567Integer m = new Integer(100); //在缓存区范围int n = 100;System.out.println(m == n); //true 基本数据类型比较，这里的m会自动拆箱为int类型，再与n进行数值比较，非对象地址值比较。Integer m2 = new Integer(200); //不在缓存区范围int n2 = 200;System.out.println(m2 == n2); //true 同理。仅仅是数值作比较 当new XXX 的时候比较的就是堆中的地址,但这里是基本int基本数据类型比较 再看数值比较情况不同的情况 1234567891011Integer m = 200;Double n = 200.0;System.out.println(m.equals(n)); //false//根据equals方法思考原因public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; //Double 与 Integer 非同类型，返回false return value == ((Integer)obj).intValue(); &#125; return false; &#125; &emsp; 以上。","comments":true,"tags":[{"name":"basic","slug":"basic","permalink":"https://pcp20.github.io/tags/basic/"}]},{"title":"你好","date":"2020-03-17T16:00:00.000Z","path":"2020/03/18/basic/Hi/","text":"有时候我觉得，我们确实需要点乐趣的。 以上。","comments":true,"tags":[{"name":"notes","slug":"notes","permalink":"https://pcp20.github.io/tags/notes/"}]}]